//
// Generated by JTB 1.3.2
//

package visitor;
import syntaxtree.*;
import java.util.*;


/**
 * Provides default methods which visit each node in the tree in depth-first
 * order.  Your visitors may extend this class.
 */

class Interval{
   int start;
   int end;
   String temp;
   Interval(int s, int e, String t){
      start = s;
      end = e;
      temp = t;
   }
}

class Proc{
   int spilledCount;
   int maximumArgu;
   int thisArgu;
   String name;
   Map<String, Interval>temps;
   Map<String, String>allocated;
   Map<String, Integer>spilled;
   Proc(){
      spilledCount = 0;
      maximumArgu = 0;
      thisArgu = 0;
      name = "";
      temps = new HashMap<>();
      allocated = new HashMap<>();
      spilled = new HashMap<>();
   }
}


public class miniRA extends GJNoArguDepthFirst<String> {
   //
   // Auto class visitors--probably don't need to be overridden.
   //

   
   Map<String, Proc>procs = new HashMap<>();
   Proc currentProc = null;
   Map<Interval, Integer>active = new HashMap<>();
   Vector<String>freeRegisters = new Vector<>();
   Map<String, Integer>labels = new HashMap<>();
   Map<String, String>allLabels = new HashMap<>();
   Map<String, String>procLabels = new HashMap<>();


   String procedure = "";
   String stmtlst = "";
   String arguList = "";
   String retReg = "";
   String vfree = "v1";

   boolean store = false;
   boolean fromsimple = false;
   boolean argu = false;
   boolean callUse = false;
   boolean jump = false;
   boolean fromStack = false;
   boolean procll = false;

   int line = 0;
   int spillCount = 0;
   int arguCount = 0;
   int numOfSpilled = 0;
   int maxArgu = 0;
   int totLabels = 0;

   public static Map<Interval, Integer>sortByValue(Map<Interval, Integer> map) {
      List<Map.Entry<Interval, Integer>> list = new LinkedList<Map.Entry<Interval, Integer>>(map.entrySet());
      Collections.sort(list, new Comparator<Map.Entry<Interval, Integer>>() {
         public int compare(Map.Entry<Interval, Integer> o1,
                            Map.Entry<Interval, Integer> o2) {
            return (o1.getValue()).compareTo(o2.getValue());
         }
      });
   
      Map<Interval, Integer> result = new LinkedHashMap<Interval, Integer>();
      for (Map.Entry<Interval, Integer> entry : list) {
         result.put(entry.getKey(), entry.getValue());
      }
      return result;
   }


   public void freeall(){
      active = new HashMap<>();
      freeRegisters = new Vector<>();
      freeRegisters.add("s0");
      freeRegisters.add("s1");
      freeRegisters.add("s2");
      freeRegisters.add("s3");
      freeRegisters.add("s4");
      freeRegisters.add("s5");
      freeRegisters.add("s6");
      freeRegisters.add("s7");
      freeRegisters.add("t0");
      freeRegisters.add("t1");
      freeRegisters.add("t2");
      freeRegisters.add("t3");
      freeRegisters.add("t4");   
      freeRegisters.add("t5");
      freeRegisters.add("t6");
      freeRegisters.add("t7");
      freeRegisters.add("t8");
      freeRegisters.add("t9");
      spillCount = 0;
   }


   public void expireOld(Interval i, Proc proc){

      active = sortByValue(active);
      Iterator<Interval>it = active.keySet().iterator();
      while(it.hasNext()){
         Interval j = it.next();
         if(j.end >= i.start){
            return;
         }
         it.remove();
         freeRegisters.add(proc.allocated.get(j.temp));
      }

   }


   public void spillInterval(Interval i, Proc proc){
      Interval spill = null;
      active = sortByValue(active);
      for(Interval j : active.keySet()){
         spill = j;
      }

      if(spill.end > i.end){
         String reg = proc.allocated.get(spill.temp);
         proc.allocated.remove(spill.temp);
         proc.spilled.put(spill.temp, spillCount++);
         proc.allocated.put(i.temp, reg);
         active.remove(spill);
         active.put(i, i.end);
      }
      else{
         proc.spilled.put(i.temp, spillCount++);
      }
   }


   public void linearScan(Proc proc){

      freeall();      

      Map<Interval, Integer>intervals = new HashMap<>();
      for(String s : proc.temps.keySet()){
         Interval i = proc.temps.get(s);
         intervals.put(i, i.start);
      }

      intervals = sortByValue(intervals);

      for(Interval i : intervals.keySet()){
         expireOld(i, proc);
         if(active.size() == 18){
            spillInterval(i, proc);
         }
         else{
            proc.allocated.put(i.temp, freeRegisters.get(0));
            freeRegisters.remove(0);
            active.put(i, i.end);
         }
      }
   }

   public String visit(NodeList n) {
      String ans = "";
      int _count=0;
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         e.nextElement().accept(this);
         _count++;
      }
      return ans ;
   }

   public String visit(NodeListOptional n) {
      if ( n.present() ) {
         String ans = "";
         int _count=0;
         for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
            e.nextElement().accept(this);
            _count++;
         }
         return ans ; 
      }
      else
         return null;
   }

   public String visit(NodeOptional n) {
      if ( n.present() )
         return n.node.accept(this);
      else
         return null;
   }

   public String visit(NodeSequence n) {
      String ans = "";
      int _count=0;
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         e.nextElement().accept(this);
         _count++;
      }
      return ans ; 
   }

   public String visit(NodeToken n) { return null; }

   //
   // User-generated visitor methods below
   //

   /**
    * f0 -> "MAIN"
    * f1 -> StmtList()
    * f2 -> "END"
    * f3 -> ( Procedure() )*
    * f4 -> <EOF>
    */
   public String visit(Goal n) {
      String ans = "";
      n.f0.accept(this);
      Proc p = new Proc();
      line = 0;
      currentProc = p;
      p.name = "MAIN";
      numOfSpilled = 0;
      maxArgu = 0;
      n.f1.accept(this);
      procs.put("MAIN", p);
      p.spilledCount = numOfSpilled;
      p.maximumArgu = maxArgu;
      p.thisArgu = 0;
      n.f2.accept(this);
      n.f3.accept(this);
      n.f4.accept(this);

      for(String s : procs.keySet()){
         Proc p1 = procs.get(s);
         linearScan(p1);
         p1.spilledCount += p1.spilled.size();
      }


      store = true;
      
      procll = true;
      n.f0.accept(this);
      procll = false;
      stmtlst = "";
      Proc p1 = new Proc();
      currentProc = p1;
      p1.name = "MAIN";
      procLabels.clear();
      numOfSpilled = procs.get("MAIN").spilled.size();
      ans += "MAIN [0] " + "[" + (procs.get("MAIN").spilledCount) + "] " + "[" + procs.get("MAIN").maximumArgu + "]\n";
      ans += n.f1.accept(this);
      n.f2.accept(this);
      ans += stmtlst;
      ans += "END\n";
      if(procs.get(currentProc.name).spilled.size() > 0){
         ans += "// SPILLED\n";
      }
      else{
         ans += "// NOTSPILLED\n";
      }
      procedure = "";
      n.f3.accept(this);
      ans += procedure;
      n.f4.accept(this);
      System.out.println(ans);

      return ans ; 
   }

   /**
    * f0 -> ( ( Label() )? Stmt() )*
    */
   public String visit(StmtList n) {
      String ans = "";
      n.f0.accept(this);
      return ans ; 
   }

   /**
    * f0 -> Label()
    * f1 -> "["
    * f2 -> IntegerLiteral()
    * f3 -> "]"
    * f4 -> StmtExp()
    */
   public String visit(Procedure n) {
      String ans = "";
      jump = true;
      procll = true;
      n.f0.accept(this);
      jump = false;
      procll = false;
      Proc p = new Proc();
      currentProc = p;
      p.name = n.f0.f0.tokenImage;
      p.thisArgu = Integer.parseInt(n.f2.f0.tokenImage);
      line = 0;
      n.f1.accept(this);
      n.f2.accept(this);
      n.f3.accept(this);
      int extra = Integer.parseInt(n.f2.f0.tokenImage) - 4;
      if(extra < 0){
         extra = 0;
      }
      if(store){
         ans += n.f0.f0.tokenImage + " [" + n.f2.f0.tokenImage + "] " + "[" + (procs.get(currentProc.name).spilledCount) + "] " + "[" + procs.get(currentProc.name).maximumArgu + "]\n";
         numOfSpilled = procs.get(currentProc.name).spilled.size() + extra;
         for(int j = 0; j < 8; j++){
            ans += "ASTORE SPILLEDARG " + (j + numOfSpilled) + " s" + j + "\n";
         }
         numOfSpilled += 8;
         int i = Integer.parseInt(n.f2.f0.tokenImage);
         for(int j = 0; j < i; j++){
            if(procs.get(currentProc.name).allocated.get("TEMP " + j) == null){
               if(j < 4){
                  ans += "ASTORE SPILLEDARG " + (procs.get(currentProc.name).spilled.get("TEMP " + j) + extra) + " a" + j + "\n";
               }
               else{
                  ans += "ALOAD " + vfree + " SPILLEDARG " + (j - 4) + "\n";
                  ans += "ASTORE" + " SPILLEDARG " + (procs.get(currentProc.name).spilled.get("TEMP " + j) + extra) + " " + vfree + "\n";
               }
            }
            else if(j < 4){
               ans += "MOVE " + procs.get(currentProc.name).allocated.get("TEMP " + j) + " a" + j + "\n";
            }
            else{
               ans += "ALOAD " + procs.get(currentProc.name).allocated.get("TEMP " + j) + " SPILLEDARG " + (j - 4) + "\n";
            }
         }
      }
      else{
         numOfSpilled = 8 + extra;
         maxArgu = 0;
      }
      callUse = false;
      procLabels.clear();
      if(!store){
         for(int j = 0; j < Integer.parseInt(n.f2.f0.tokenImage); j++){
            currentProc.temps.put("TEMP " + j, new Interval(0, line, "TEMP " + j));
         }
      }
      ans += n.f4.accept(this);
      if(!store){procs.put(n.f0.f0.tokenImage, p);}
      if(store){
         if(procs.get(currentProc.name).spilled.size() > 0){
            ans += "// SPILLED\n";
         }
         else{
            ans += "// NOTSPILLED\n";
         }
      }
      procedure += ans + "\n";
      if(!store){
         currentProc.spilledCount = numOfSpilled;
         currentProc.maximumArgu = maxArgu;
      }
      return ans ; 
   }

   /**
    * f0 -> NoOpStmt()
    *       | ErrorStmt()
    *       | CJumpStmt()
    *       | JumpStmt()
    *       | HStoreStmt()
    *       | HLoadStmt()
    *       | MoveStmt()
    *       | PrintStmt()
    */
   public String visit(Stmt n) {
      String ans = "";
      if(!store){
         line++;
      }
      stmtlst += n.f0.accept(this);
      return ans ; 
   }

   /**
    * f0 -> "NOOP"
    */
   public String visit(NoOpStmt n) {
      String ans = "";
      ans += "NOOP\n";
      n.f0.accept(this);
      return ans ; 
   }

   /**
    * f0 -> "ERROR"
    */
   public String visit(ErrorStmt n) {
      String ans = "";
      ans += "ERROR\n";
      n.f0.accept(this);
      return ans ; 
   }

   /**
    * f0 -> "CJUMP"
    * f1 -> Temp()
    * f2 -> Label()
    */
   public String visit(CJumpStmt n) {
      String ans = "";
      n.f0.accept(this);
      String s = n.f1.accept(this);
      String r = retReg;
      if(!store){
         if(currentProc.temps.containsKey("TEMP " + n.f1.f1.f0.tokenImage)){
            currentProc.temps.get("TEMP " + n.f1.f1.f0.tokenImage).end = line;
         }
         else{
            currentProc.temps.put("TEMP " + n.f1.f1.f0.tokenImage, new Interval(line, line, "TEMP " + n.f1.f1.f0.tokenImage));
         }
      }
      jump = true;
      n.f2.accept(this);
      jump = false;
      if(!s.equals("")){ans += s + "\n";} 
      if(store){ans += "CJUMP " + r + " " + procLabels.get(n.f2.f0.tokenImage) + "\n";}
      return ans; 
   }

   /**
    * f0 -> "JUMP"
    * f1 -> Label()
    */
   public String visit(JumpStmt n) {
      String ans = "";
      n.f0.accept(this);
      jump = true;
      if(!store){
         for(String s : currentProc.temps.keySet()){
            Interval i = currentProc.temps.get(s);
            Integer j = labels.get(n.f1.f0.tokenImage);
            if(j != null && i.start <= j && i.end >= j){
               i.end = line;
            }
         }
      }
      n.f1.accept(this);
      jump = false;
      if(store){ans += "JUMP " + procLabels.get(n.f1.f0.tokenImage) + "\n";}
      return ans ; 
   }

   /**
    * f0 -> "HSTORE"
    * f1 -> Temp()
    * f2 -> IntegerLiteral()
    * f3 -> Temp()
    */
   public String visit(HStoreStmt n) {
      String ans = "";
      n.f0.accept(this);
      String s1 = n.f1.accept(this);
      String r1 = retReg;
      boolean f1 = fromStack;
      if(!store){
         if(currentProc.temps.containsKey("TEMP " + n.f1.f1.f0.tokenImage)){
            currentProc.temps.get("TEMP " + n.f1.f1.f0.tokenImage).end = line;
         }
         else{
            currentProc.temps.put("TEMP " + n.f1.f1.f0.tokenImage, new Interval(line, line, "TEMP " + n.f1.f1.f0.tokenImage));
         }
      }
      n.f2.accept(this);
      String s2 = n.f3.accept(this);
      String r2 = retReg;
      if(!store){
         if(currentProc.temps.containsKey("TEMP " + n.f3.f1.f0.tokenImage)){
            currentProc.temps.get("TEMP " + n.f3.f1.f0.tokenImage).end = line;
         }
         else{
            currentProc.temps.put("TEMP " + n.f3.f1.f0.tokenImage, new Interval(line, line, "TEMP " + n.f3.f1.f0.tokenImage));
         }
      }
      if(!s1.equals("")){ans += s1 + "\n";}
      if(!s2.equals("")){ans += s2 + "\n";}
      ans += "HSTORE " + r1 + " " + n.f2.f0.tokenImage + " " + r2 + "\n";
      return ans ; 
   }

   /**
    * f0 -> "HLOAD"
    * f1 -> Temp()
    * f2 -> Temp()
    * f3 -> IntegerLiteral()
    */
   public String visit(HLoadStmt n) {
      String ans = "";
      n.f0.accept(this);
      String s1 = n.f1.accept(this);
      String r1 = retReg;
      boolean f1 = fromStack;
      if(!store){
         if(currentProc.temps.containsKey("TEMP " + n.f1.f1.f0.tokenImage)){
            currentProc.temps.get("TEMP " + n.f1.f1.f0.tokenImage).end = line;
         }
         else{
            currentProc.temps.put("TEMP " + n.f1.f1.f0.tokenImage, new Interval(line, line, "TEMP " + n.f1.f1.f0.tokenImage));
         }
      }
      String s2 = n.f2.accept(this);
      String r2 = retReg;
      if(!store){
         if(currentProc.temps.containsKey("TEMP " + n.f2.f1.f0.tokenImage)){
            currentProc.temps.get("TEMP " + n.f2.f1.f0.tokenImage).end = line;
         }
         else{
            currentProc.temps.put("TEMP " + n.f2.f1.f0.tokenImage, new Interval(line, line, "TEMP " + n.f2.f1.f0.tokenImage));
         }
      }
      n.f3.accept(this);
      if(!s1.equals("")){ans += s1 + "\n";}
      if(!s2.equals("")){ans += s2 + "\n";}
      ans += "HLOAD" + " " + r1 + " " + r2 + " " + n.f3.f0.tokenImage + "\n";
      int extra = 0;
      if(store){
         extra = procs.get(currentProc.name).thisArgu - 4;
         if(extra < 0){
            extra = 0;
         }
      }
      if(store && f1){
         ans += "ASTORE" + " SPILLEDARG " + (procs.get(currentProc.name).spilled.get("TEMP " + n.f1.f1.f0.tokenImage) + extra) + " " + r1 + "\n";
      }
      return ans ; 
   }

   /**
    * f0 -> "MOVE"
    * f1 -> Temp()
    * f2 -> Exp()
    */
   public String visit(MoveStmt n) {
      String ans = "";
      n.f0.accept(this);
      String s1 = n.f1.accept(this);
      String r1 = retReg;
      boolean f1 = fromStack;
      if(!s1.equals("")){ans += s1 + "\n";}
      if(!store){
         if(currentProc.temps.containsKey("TEMP " + n.f1.f1.f0.tokenImage)){
            currentProc.temps.get("TEMP " + n.f1.f1.f0.tokenImage).end = line;
         }
         else{
            currentProc.temps.put("TEMP " + n.f1.f1.f0.tokenImage, new Interval(line, line, "TEMP " + n.f1.f1.f0.tokenImage));
         }
      }
      String s2 = n.f2.accept(this);
      String r2 = retReg;
      boolean f2 = fromStack;
      if(!s2.equals("")){
         ans += s2 + "\n";
      }
      ans += "MOVE " + r1 + " " + r2 + "\n";
      int extra = 0;
      if(store){
         extra = procs.get(currentProc.name).thisArgu - 4;
         if(extra < 0){
            extra = 0;
         }
      }
      if(store && f1){
         ans += "ASTORE" + " SPILLEDARG " + (procs.get(currentProc.name).spilled.get("TEMP " + n.f1.f1.f0.tokenImage) + extra) + " " + r1 + "\n";
      }
      return ans ; 
   }

   /**
    * f0 -> "PRINT"
    * f1 -> SimpleExp()
    */
   public String visit(PrintStmt n) {
      String ans = "";
      n.f0.accept(this);
      String s = n.f1.accept(this);
      String r = retReg;
      if(!s.equals("")){ans += s + "\n";}
      ans += "PRINT " + r + "\n";
      return ans ; 
   }

   /**
    * f0 -> Call()
    *       | HAllocate()
    *       | BinOp()
    *       | SimpleExp()
    */
   public String visit(Exp n) {
      String ans = "";
      ans += n.f0.accept(this);
      return ans ; 
   }

   /**
    * f0 -> "BEGIN"
    * f1 -> StmtList()
    * f2 -> "RETURN"
    * f3 -> SimpleExp()
    * f4 -> "END"
    */
   public String visit(StmtExp n) {
      String ans = "";
      n.f0.accept(this);
      String temp = stmtlst;
      stmtlst = "";
      n.f1.accept(this);
      ans += stmtlst;
      stmtlst = temp;
      n.f2.accept(this);
      String s = n.f3.accept(this);
      String r = retReg;
      if(!s.equals("")){ans += s + "\n";}
      ans += "MOVE v0 " + r;
      if(store){
         int extra = procs.get(currentProc.name).thisArgu - 4;
         if(extra < 0){
            extra = 0;
         }
         for(int j = 0; j < 8; j++){
            ans += "\nALOAD s" + j + " SPILLEDARG " + (j + procs.get(currentProc.name).spilled.size() + extra);
         }
      }
      ans += "\nEND\n";
      n.f4.accept(this);
      return ans ; 
   }

   /**
    * f0 -> "CALL"
    * f1 -> SimpleExp()
    * f2 -> "("
    * f3 -> ( Temp() )*
    * f4 -> ")"
    */
   public String visit(Call n) {
      String ans = "";
      n.f0.accept(this);
      String s1 = n.f1.accept(this);
      String r1 = retReg;
      n.f2.accept(this);
      fromsimple = true;
      argu = true;
      arguCount = 0;
      arguList = "";
      n.f3.accept(this);
      argu = false;
      fromsimple = false;
      n.f4.accept(this);
      if(store){
         for(int j = 0; j < 10; j++){
            ans += "ASTORE SPILLEDARG " + (j + numOfSpilled) + " t" + j + "\n";
         }
      }
      ans += arguList;
      ans += s1 + "\n";
      ans += "CALL " + r1 + "\n";
      if(store){
         for(int j = 0; j < 10; j++){
            ans += "ALOAD " + "t" + j + " SPILLEDARG " + (j + numOfSpilled) + "\n"; 
         }
      }
      retReg = "v0";
      if(!store){
         if(!callUse){
            numOfSpilled += 10;
            callUse = true;
         }
         if(maxArgu < arguCount){
            maxArgu = arguCount;
         }
      }
      return ans ; 
   }

   /**
    * f0 -> "HALLOCATE"
    * f1 -> SimpleExp()
    */
   public String visit(HAllocate n) {
      String ans = "";
      n.f0.accept(this);
      String s = n.f1.accept(this);
      String r = retReg;
      if(!s.equals("")){ans += s + "\n";}
      retReg = "HALLOCATE " + r;
      return ans ; 
   }

   /**
    * f0 -> Operator()
    * f1 -> Temp()
    * f2 -> SimpleExp()
    */
   public String visit(BinOp n) {
      String ans = "";
      String op = n.f0.accept(this);
      String s1 = n.f1.accept(this);
      String r1 = retReg;
      if(!store){
         if(currentProc.temps.containsKey("TEMP " + n.f1.f1.f0.tokenImage)){
            currentProc.temps.get("TEMP " + n.f1.f1.f0.tokenImage).end = line;
         }
         else{
            currentProc.temps.put("TEMP " + n.f1.f1.f0.tokenImage, new Interval(line, line, "TEMP " + n.f1.f1.f0.tokenImage));
         }
      }
      String s2 = n.f2.accept(this);
      String r2 = retReg;
      if(!s1.equals("")){ans += s1 + "\n";}
      if(!s2.equals("")){ans += s2 + "\n";}
      retReg = op + r1 + " " + r2;
      return ans ; 
   }

   /**
    * f0 -> "LE"
    *       | "NE"
    *       | "PLUS"
    *       | "MINUS"
    *       | "TIMES"
    *       | "DIV"
    */
   public String visit(Operator n) {
      String ans = "";
      n.f0.accept(this);
      int i = n.f0.which;
      if(i == 0){
         ans += "LE ";
      }
      else if(i == 1){
         ans += "NE ";
      }
      else if(i == 2){
         ans += "PLUS ";
      }
      else if(i == 3){
         ans += "MINUS ";
      }
      else if(i == 4){
         ans += "TIMES ";
      }
      else if(i == 5){
         ans += "DIV ";
      }
      retReg = ans;
      return ans ; 
   }

   /**
    * f0 -> Temp()
    *       | IntegerLiteral()
    *       | Label()
    */
   public String visit(SimpleExp n) {
      String ans = "";
      fromsimple = true;
      String s = n.f0.accept(this);
      String r = retReg;
      ans += s;
      fromsimple = false;
      return ans ; 
   }

   /**
    * f0 -> "TEMP"
    * f1 -> IntegerLiteral()
    */
   public String visit(Temp n) {
      n.f0.accept(this);
      n.f1.accept(this);
      String ans = "";
      if(fromsimple && !store){
         if(currentProc.temps.containsKey("TEMP " + n.f1.f0.tokenImage)){
            currentProc.temps.get("TEMP " + n.f1.f0.tokenImage).end = line;
         }
         else{
            currentProc.temps.put("TEMP " + n.f1.f0.tokenImage, new Interval(line, line, "TEMP " + n.f1.f0.tokenImage));
         }
      }
      if(store && !argu){
         ans = "";
         retReg = procs.get(currentProc.name).allocated.get("TEMP " + n.f1.f0.tokenImage);
         fromStack = false;
         if(procs.get(currentProc.name).spilled.get("TEMP " + n.f1.f0.tokenImage) != null){
            int ext = procs.get(currentProc.name).thisArgu - 4;
            if(ext < 0){
               ext = 0;
            }
            ans += "ALOAD " + vfree + " SPILLEDARG " + (procs.get(currentProc.name).spilled.get("TEMP " + n.f1.f0.tokenImage) + ext) + "\n";
            retReg = vfree;
            fromStack = true;
            if(vfree == "v0"){
               vfree = "v1";
            }
            else{
               vfree = "v0";
            }
         }
      }
      else if(store && argu){
         String spargu = procs.get(currentProc.name).allocated.get("TEMP " + n.f1.f0.tokenImage);
         int ext = procs.get(currentProc.name).thisArgu - 4;
         if(ext < 0){
            ext = 0;
         }
         if(procs.get(currentProc.name).spilled.get("TEMP " + n.f1.f0.tokenImage) != null){
            ans += "ALOAD " + vfree + " SPILLEDARG " + (procs.get(currentProc.name).spilled.get("TEMP " + n.f1.f0.tokenImage) + ext) + "\n";
            spargu = vfree;
         }
         if(arguCount < 4){
            ans += "MOVE a" + arguCount + " " + spargu + "\n";
         }
         else{
            ans += "PASSARG " + (arguCount - 3) + " " + spargu + "\n";
         }
         retReg = "";
         arguList += ans;
         arguCount++;
      }
      else if(!store && argu){
         arguCount++;
      }
      return ans ; 
   }

   /**
    * f0 -> <INTEGER_LITERAL>
    */
   public String visit(IntegerLiteral n) {
      String ans = "";
      retReg = n.f0.tokenImage;
      n.f0.accept(this);
      return ans ; 
   }

   /**
    * f0 -> <IDENTIFIER>
    */
   public String visit(Label n) {
      if(!fromsimple && !store && !jump){
         line++;
         labels.put(n.f0.tokenImage, line);
         totLabels++;
      }
      if(store){
         boolean check = true;
         String s = n.f0.tokenImage;
         if (s.charAt(0) == 'L'){
            for(int i = 1; i < s.length(); i++){
               char c = s.charAt(i);
               if (!Character.isDigit(c)) {
                   check = false;
               }
            }
         }
         else{
            check = false;
         }
         if(check && allLabels.get(n.f0.tokenImage) != null){
            if(procLabels.get(n.f0.tokenImage) == null){
               procLabels.put(n.f0.tokenImage, "L" + totLabels);
               totLabels++;
            }
         }
         else if(check){
            allLabels.put(n.f0.tokenImage, n.f0.tokenImage);
            procLabels.put(n.f0.tokenImage, n.f0.tokenImage);
         }
         if(!check && store){
            procLabels.put(n.f0.tokenImage, n.f0.tokenImage);
         }
      }
      String ans = "";
      if(store){
         stmtlst += procLabels.get(n.f0.tokenImage) + "\n";
         retReg = procLabels.get(n.f0.tokenImage);
      }
      n.f0.accept(this);
      return ans ; 
   }

}
